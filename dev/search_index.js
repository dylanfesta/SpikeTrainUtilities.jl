var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SpikeTrainUtilities","category":"page"},{"location":"#SpikeTrainUtilities","page":"Home","title":"SpikeTrainUtilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SpikeTrainUtilities.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SpikeTrainUtilities]","category":"page"},{"location":"#SpikeTrainUtilities.SpikeTrains","page":"Home","title":"SpikeTrainUtilities.SpikeTrains","text":"SpikeTrains(nunits::N,trains::Vector{Vector{R}},tstart::R,t_end::R) where {R,N}\n\nConstructs a SpikeTrains object.  \n\n\n\n\n\n","category":"type"},{"location":"#SpikeTrainUtilities.bin_spikes-Union{Tuple{N}, Tuple{R}, Tuple{SpikeTrains{R, N}, R}} where {R, N}","page":"Home","title":"SpikeTrainUtilities.bin_spikes","text":"bin_spikes(S::SpikeTrains{R,N},dt::R) where {R,N}\n\nArguments\n\nS : SpikeTrains object\ndt : time bin size\n\nReturns\n\ntimesbin::Vector{R} : `timesbin[k]is the midpoint of the timebink(i.e.S.t_start + (k-1/2)*dt`)   \nbinned_spikes::Matrix{<:Integer} : binned_spikes[k,i] is the number of spikes that occur    in the timebin k for neuron i  (i.e. between S.t_start + (k-1)*dt and S.t_start + k*dt)\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.bin_spikes-Union{Tuple{N}, Tuple{R}, Tuple{SpikeTrains{R, N}, Vector{R}}} where {R, N}","page":"Home","title":"SpikeTrainUtilities.bin_spikes","text":"bin_spikes(S::SpikeTrains{R,N},binvector::Vector{R}) where {R,N}\n\nArguments\n\nS : SpikeTrains object\nbinvector : vector of bin edges\n\nReturns\n\ntimesbin::Vector{R} : `timesbin[k]is the midpoint of the timebink(i.e.binvector[k] + (binvector[k+1]-binvector[k])/2`)   \nbinned_spikes::Matrix{<:Integer} : binned_spikes[k,i] is the number of spikes that occur    in the timebin k for neuron i  (i.e. between binvector[k] and binvector[k+1])\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.bin_spikes-Union{Tuple{R}, Tuple{Vector{R}, AbstractVector{R}}} where R<:Real","page":"Home","title":"SpikeTrainUtilities.bin_spikes","text":"bin_spikes(Y::Vector{R},binvector::Vector{R}) where R\n\nArguments\n\nY::Vector{<:Real} : vector of spike times\nbinvector::AbstractVector{<:Real} : vector of bin edges\n\nReturns\n\ntimes_bin::Vector{R} : times_bin[k] is the midpoint of the timebin k (i.e. binvector[k] + (binvector[k+1]-binvector[k])/2)   \nbinned_spikes::Vector{<:Integer} : binned_spikes[k] is the number of spikes that occur    in the timebin k  (i.e. between binvector[k] and binvector[k+1])\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.bin_spikes-Union{Tuple{R}, Tuple{Vector{R}, R, R}} where R","page":"Home","title":"SpikeTrainUtilities.bin_spikes","text":"bin_spikes(Y::Vector{R},dt::R,Tend::R;Tstart::R=0.0) where R\n\nArguments\n\nY::Vector{<:Real} : vector of spike times\ndt::Real : time bin size\nTend::Real : end time for the raster\n\nOptional argument\n\nTstart::Real=0.0 : start time for the raster\n\nReturns\n\ntimesbin::Vector{R} : `timesbin[k]is the midpoint of the timebink(i.e.Tstart + (k-1/2)*dt`)   \nbinned_spikes::Vector{<:Integer} : binned_spikes[k] is the number of spikes that occur    in the timebin k  (i.e. between Tstart + (k-1)*dt and Tstart + k*dt)\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.circular_shift_of_spiketrains-Union{Tuple{SpikeTrainUtilities.SpikeQuantity{R, N_SQ, T_SQ}}, Tuple{T_SQ}, Tuple{N_SQ}, Tuple{R}} where {R, N_SQ, T_SQ}","page":"Home","title":"SpikeTrainUtilities.circular_shift_of_spiketrains","text":"function circularshiftofspiketrains(sq::SpikeQuantity; shiftquantity::Bool=true)\n\nPerform a circular shuffle of the event times in sq. This function randomly shifts each event time series by a random amount, wrapping around the duration of the SpikeQuantity object. If shift_quantity is true (default), the corresponding ys values are shifted along with their event times, maintaining their association after sorting. If shift_quantity is false, event_times are shifted and sorted, but the ys vectors for each unit are copied from the original SpikeQuantity without reordering.  Thus, the i-th value in new_ys[k] will correspond to the i-th time in the newly sorted new_event_times[k], which may differ from its original association if the circular shift altered the temporal order of events.\n\nThe function returns a new SpikeQuantity object with the shuffled event times (and potentially ys), and the random shifts applied to each series. The random shifts are generated uniformly in the range [0, duration), where duration is the total duration of the SpikeQuantity.\n\nArguments\n\nsq::SpikeQuantity: The input spike quantity to be shuffled. It must have a positive duration.\nshift_quantity::Bool: If true (default), ys values follow their corresponding event times through the shift and sort. If false, ys vectors are copied directly from the input sq for each unit without reordering relative to the new sorted event times.\n\nReturns\n\nNew SpikeQuantity object with the shuffled event times and ys.\nVector of random shifts applied to each event time series.\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.circular_shift_of_spiketrains-Union{Tuple{SpikeTrains{R, N_units_type, T_units_type}}, Tuple{T_units_type}, Tuple{N_units_type}, Tuple{R}} where {R, N_units_type, T_units_type}","page":"Home","title":"SpikeTrainUtilities.circular_shift_of_spiketrains","text":"function circularshiftof_spiketrains(spk::SpikeTrains)\n\nPerform a circular shuffle of the spike trains in spk. This function randomly shifts each spike train by a random amount, wrapping around the duration of the spike trains. The function returns a new SpikeTrains object with the shuffled spike times, and the random shifts applied to each train. The random shifts are generated uniformly in the range [0, duration), where duration is the total duration of the spike trains.\n\nArguments\n\nspk::SpikeTrains: The input spike trains to be shuffled. It must have a positive duration.\n\nReturns\n\nNew SpikeTrains object with the shuffled spike times.\nVector of random shifts applied to each spike train.\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.draw_spike_raster-Union{Tuple{C}, Tuple{Vector{Vector{Float64}}, Real, Real}} where C<:ColorTypes.Color","page":"Home","title":"SpikeTrainUtilities.draw_spike_raster","text":"drawspikeraster(trains::Vector{Vector{Float64}},       dt::Real,Tend::Real;       Tstart::Real=0.0,       spikesize::Integer = 5,       spikeseparator::Integer = 1,       backgroundcolor::Color=RGB(1.,1.,1.),       spikecolors::Union{C,Vector{C}}=RGB(0.,0.0,0.0),       max_size::Real=1E4) where C<:Color\n\nDraws a matrix that contains the raster plot of the spike train.\n\nArguments\n\nTrains :  Vector of spike trains. The order of the vector corresponds to  the order of the plot. First element is at the top, second is second row, etc.\ndt : time interval representing one horizontal pixel  \nTend : final time to be considered\n\nOptional arguments\n\nTstart::Real : starting time\nspike_size::Integer : heigh of spike (in pixels)\nspike_separator::Integer : space between spikes, and vertical padding\nbackground_color::Color : self-explanatory\nspike_colors::Union{Color,Vector{Color}} : if a single color, color of all spikes, if vector of colors,   color for each neuron (length should be same as number of neurons)\nmax_size::Integer : throws an error if image is larger than this number (in pixels)\n\nReturns\n\nraster_matrix::Matrix{Color} you can save it as a png file\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.filter_out_small_isi!-Tuple{SpikeTrains, Real}","page":"Home","title":"SpikeTrainUtilities.filter_out_small_isi!","text":"function filteroutsmallisi!(spiketrains::SpikeTrains, dtmin::Real)\n\nFilter out spikes (events) that are closer than dt_min from each other in the spike trains object This modifies the input spiketrains in place, removing spikes that are too close together.\n\nArguments:\n\nspiketrains::SpikeTrains: An instance of SpikeTrains, which contains multiple spike trains.\ndt_min::Real: The minimum time difference between spikes. Spikes closer than this will be removed.\n\nReturns:\n\nnothing, modifies spiketrains in place.\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.filter_out_small_isi!-Tuple{Vector{<:AbstractVector{<:Real}}, Real}","page":"Home","title":"SpikeTrainUtilities.filter_out_small_isi!","text":"function filteroutsmallisi!(spiketrains::Vector{<:AbstractVector{<:Real}}, dtmin::Real)\n\nFilter out spikes (events) that are closer than dt_min from each other in the given spiketrains. This modifies the input spiketrains in place, removing spikes that are too close together.\n\nArguments:\n\nspiketrains::Vector{<:AbstractVector{<:Real}}: A vector of spike trains, where each train is an array of spike times.\ndt_min::Real: The minimum time difference between spikes. Spikes closer than this will be removed.\n\nReturns:\n\nnothing, modifies spiketrains in place.\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.get_instantaneous_firing_rates-Union{Tuple{SpikeTrains{R, N, T}}, Tuple{T}, Tuple{N}, Tuple{R}} where {R, N, T}","page":"Home","title":"SpikeTrainUtilities.get_instantaneous_firing_rates","text":"function getinstantaneousfiringrates(spiketrains::SpikeTrains; dtmin::Real=0.0)\n\nCalculate the instantaneous firing rates, iFR, defined as 1/ISI, for each spike train in the spiketrains object. The iFR time is defined as the time of the right spike in the ISI.\n\nArguments:\n\nspiketrains::SpikeTrains: An instance of SpikeTrains, which contains multiple spike trains.\ndt_min::Real: The minimum time difference between spikes. Spikes closer than this will be removed before calculating iFR, default is 0.0, which means no filtering.\n\nReturns:\n\niFRTrains::SpikeQuantity: An instance of SpikeQuantity containing the instantaneous firing rates for each spike train. The event_times are the times of the left spikes in the ISI, and ys are the corresponding iFR values.\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.get_line_segments-Tuple{SpikeTrains, Real, Real}","page":"Home","title":"SpikeTrainUtilities.get_line_segments","text":"function getlinesegments(spiketrains::SpikeTrains,     tstart::Real,tend::Real;     heightscaling::Real=0.7,     neurons::Union{Vector{Int},Nothing}=nothing,     offset::Real = 0.0,     maxspikes::Real=1E6)\n\nReturns point coordinates that can be used for line segments for a raster plot of the spiketrain\n\nArguments\n\nspiketrains::SpikeTrains : the spiketrains\nt_start::Real : the starting time of the raster\nt_end::Real : the ending time of the raster\nheight_scaling::Real=0.7 : how tall each spike is, 1.0 is the full height\nneurons::Union{Vector{Int},Nothing}=nothing : the neurons to plot, if nothing all neurons are plotted\nneuron_offset::Real=0.0 : the y-offset of the raster\ntime_offset::Real : the time offset of the raster, default is t_start\nmax_spikes::Real=1E6 : the maximum number of spikes that can be plotted.\n\nReturns\n\npoints_linesegment : a vector of tuples of two floats, (t1,y1a),(t1,y1b),(t2,y2a),(t2,y2b),...   where t1,t2 are the times of the spikes and y1a,y1b,y2a,y2b are the y-coordinates of the line segments,  representing neurons on the y axis. This can be used directly as argument to linesegments! in Makie. \n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.line_segments_to_xynans-Union{Tuple{Array{Tuple{R, R}, 1}}, Tuple{R}} where R<:Real","page":"Home","title":"SpikeTrainUtilities.line_segments_to_xynans","text":"function linesegmentstoxynans(points::Vector{Tuple{R,R}}) where R<:Real Converts segments obtained from `getline_segments` to x and y vectors, using NaN to disconnect segments.\n\nArguments\n\npoints::Vector{Tuple{R,R}} : the points obtained from get_line_segments\n\nReturns\n\nx_plot_all::Vector{R} : x-coordinates of the points\ny_plot_all::Vector{R} : y-coordinates of the points, with NaN to disconnect segments\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.numerical_rates-Union{Tuple{SpikeTrains{R, N}}, Tuple{N}, Tuple{R}} where {R, N}","page":"Home","title":"SpikeTrainUtilities.numerical_rates","text":"numericalrates(S::SpikeTrains{R,N};tstart::R=0.0,t_end::R=Inf) where {R,N}\n\nCompute the numerical rates of the spike trains in S over the interval  [t_start,t_end] if specified. If not, uses the interval [S.t_start,S.t_end].\n\n\n\n\n\n","category":"method"},{"location":"#SpikeTrainUtilities.sort_units!-Union{Tuple{RA}, Tuple{T}, Tuple{N}, Tuple{R}, Tuple{SpikeTrains{R, N, T}, Dict{T, RA}}} where {R, N, T, RA<:Real}","page":"Home","title":"SpikeTrainUtilities.sort_units!","text":"function sortunits!(spk::SpikeTrains{R,N,T},sortingdict::Dict{T,I};strict_dictionary::Bool=true) where {R,N,T,I<:Integer}\n\nModifies the spk object in place by sorting its units according to the provided sorting_dict. The sorting_dict maps original unit identifiers (of type T) to ranking numbers. The dictionary must contain all keys that correspond to the units in spk. If strict_dictionary is true, then the dictionary must contain exactly the units present in spk and vice versa. If strict_dictionary is false, then the dictionary can contain extra keys.\n\nArguments:\n\nspk::SpikeTrains{R,N,T}: The spike trains object to be sorted.\nsorting_dict::Dict{T,RA}: A dictionary mapping unit identifiers to a ranking number.\nstrict_dictionary::Bool: If true, the function will check that the sorting_dict contains exactly the units present in spk and vice versa.   If false, it will only check that the keys in sorting_dict are a subset of the units in spk, and use the values as rankings for sorting.\n\nReturns:\n\nnothing, modifies spk in place.\n\n\n\n\n\n","category":"method"}]
}
